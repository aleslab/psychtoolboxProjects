function [expInfo] = drawFixation(expInfo, fixationInfo)
%function [expInfo] = drawFixation(expInfo, fixationInfo)
%This function is used to draw fixation markers.
% Since it is called throughout the experiment it can also be used to draw
% things that should be on screen in the intertrial interval. Currently we
% have an apeture to aid fixation in the stereo mode.
%
% ADD INSTRUCTIONS FOR DIFFERENT FIXATION OPTIONS HERE
%
% type: 'cross', 'square','noiseFrame'
% color: 
% lineWidthPix: 

nElements = length(fixationInfo);

%fixationInfo can be a structure with multiple fixation element
for iElement = 1:nElements
    
    %We need to do different things for stereo rendering
    if expInfo.stereoMode == 0;
        expInfo = drawFixationMono(expInfo,fixationInfo(iElement));
    else
        expInfo = drawFixationStereo(expInfo,fixationInfo(iElement));
    end
    
end


end




function [expInfo] = drawFixationMono(expInfo,fixationInfo)


if  ~isfield(fixationInfo,'lineWidthPix') || isempty(fixationInfo.lineWidthPix)
    fixationInfo.lineWidthPix = 1; %the line width of the fixation cross
end

if ~isfield(fixationInfo,'color') || isempty(fixationInfo.color)
    fixationInfo.color = 0; %the color of the fixation cross.
end

%Switchyard to determine what to draw.
switch lower(fixationInfo.type)
    
    
    case 'cross'
        
        if ~isfield(fixationInfo,'size') || isempty(fixationInfo.size)
            fixationInfo.size = 20/expInfo.ppd; %Default cross size is 10 
            %pixels for backwards compatability. -- AL: Each arm of the 
            %cross was 10 pixels previously, so the line size for drawing 
            %the horizontal and vertical lines to make the cross was 20 pixels. 
            %With 10 pixels as the size the fixation cross is too small, so 
            %I've changed it to 20 so that it is consistent with how my experiment was run previously.
        end
        
        fixCrossPix    = expInfo.ppd*fixationInfo.size;
        fixCoords = [-fixCrossPix fixCrossPix 0 0;... %fixation cross x coordinates
            0 0 -fixCrossPix fixCrossPix]; %fixation cross y coordinates
        Screen('DrawLines', expInfo.curWindow, fixCoords, fixationInfo.lineWidthPix, ...
            fixationInfo.color, expInfo.center, 0);
        
    case 'square'
        %Consider changing this code to a framerect instead of lines for
        %simplicity.
        if ~isfield(fixationInfo,'boxSize') || isempty(fixationInfo.boxSize)
            fixationInfo.boxSize = 30/expInfo.ppd; %Default box size is 30 pixels for backwards compatability.
        end
        
        boxSizePix = expInfo.ppd*fixationInfo.boxSize;
        leftPointX = expInfo.center(1) - boxSizePix; %x centre is expInfo.center(1)
        rightPointX = expInfo.center(1) + boxSizePix;
        PointY1 = expInfo.center(2) + boxSizePix; %y centre is expInfo.center(2)
        PointY2 = expInfo.center(2) - boxSizePix;
        
        boxXcoords = [leftPointX leftPointX rightPointX rightPointX leftPointX rightPointX leftPointX rightPointX];
        boxYcoords = [PointY1 PointY2 PointY1 PointY2 PointY1 PointY1 PointY2 PointY2];
        boxCoords = [boxXcoords; boxYcoords];
        
        Screen('DrawLines', expInfo.curWindow, boxCoords, fixationInfo.lineWidthPix, ...
            fixationInfo.color);
        
        %% apeture drawing
        
    case 'noiseframe'
        
        
        [screenXpixels, screenYpixels] = Screen('WindowSize', expInfo.curWindow);
        
        if ~isfield(fixationInfo,'size') || isempty(fixationInfo.size)
            fixationInfo.size = 100;
        end
        
        if ~isfield(expInfo,'fixationTextures') || isempty(expInfo.fixationTextures)
            
            
            priorSeed = rng; %Save the current rng seed
            rng(1); %setting the random seed of this file to 1 so that the normally
            %distributed random matrix generated by randn for the left, right, top
            %and bottom rectangle textures below will not change.
            leftRectMat = randn([screenYpixels, fixationInfo.size]);
            rightRectMat = randn([screenYpixels, fixationInfo.size]);
            topHorzMat = randn([fixationInfo.size, screenXpixels]);
            bottomHorzMat = randn([fixationInfo.size, screenXpixels]);
            
            
            leftRectTexture = Screen('MakeTexture', expInfo.curWindow, leftRectMat);
            rightRectTexture = Screen('MakeTexture', expInfo.curWindow, rightRectMat);
            topHorzTexture = Screen('MakeTexture', expInfo.curWindow, topHorzMat);
            bottomHorzTexture = Screen('MakeTexture', expInfo.curWindow, bottomHorzMat);
            expInfo.fixationTextures = [leftRectTexture; rightRectTexture; topHorzTexture; bottomHorzTexture];
            rng(priorSeed);            % restore the generator settings
        end
        
        leftRectLocation = [0 0 fixationInfo.size screenYpixels];
        rightRectLocation = [(screenXpixels-fixationInfo.size) 0 screenXpixels screenYpixels];
        topRectLocation = [0 0 screenXpixels fixationInfo.size]; %this draws the top rectangle along the entire length of the top of the screen
        bottomRectLocation = [0 (screenYpixels-fixationInfo.size) screenXpixels screenYpixels];
        allLocations = [leftRectLocation; rightRectLocation; topRectLocation; bottomRectLocation]';
        
        Screen('DrawTextures', expInfo.curWindow, expInfo.fixationTextures, [], [allLocations]);
        
end


end








function [expInfo] = drawFixationStereo(expInfo,fixationInfo)
%Currently this function just draws things at 0 screen disparity by calling
%the mono fixation drawing code twice, once for each stereo buffer.

Screen('SelectStereoDrawBuffer', expInfo.curWindow, 0);
expInfo = drawFixationMono(expInfo,fixationInfo);
Screen('SelectStereoDrawBuffer', expInfo.curWindow, 1);
expInfo = drawFixationMono(expInfo,fixationInfo);

end







